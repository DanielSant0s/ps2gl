/*	  Copyright (C) 2000,2001,2002  Sony Computer Entertainment America

       	  This file is subject to the terms and conditions of the GNU Lesser
	  General Public License Version 2.1. See the file "COPYING" in the
	  main directory of this archive for more details.                             */

#ifndef renderer_h
#define renderer_h

#include "ps2s/packet.h"

#include "GL/gl.h"

/********************************************
 * flags describing what pieces of microcode can do/
 * need to do
 */

class CRendererProps {
public:
    tU64 PrimType : 3;
    tU64 Lighting : 1;
    tU64 NumDirLights : 2;
    tU64 NumPtLights : 3;
    tU64 Texture : 1;
    tU64 Specular : 1;
    tU64 PerVtxMaterial : 3;
    tU64 Clipping : 2;
    tU64 CullFace : 1;
    tU64 TwoSidedLighting : 1;
    tU64 ArrayAccess : 2;

    tU64 unused : 12;

    tU64 UserProps : 32;

    // convert to unsigned 64-bit value

    inline operator tU64() const
    {
        // this hack doesn't work on linux since the compiler thinks this is a 32-bit
        // machine..
        // asm (" ### CRendererProps to uint ### " : "=r" (value) : "0" (*this) );

        tU64* value = (tU64*)this;
        return *value;
    }

    inline void operator=(tU64 value)
    {
        // see above..
        // asm(" ### CRendererProps assign from u64 ### " : "=r" (*(tU64*)this) : "0" (value) );

        *this = *(CRendererProps*)&value;
    }
} __attribute__((aligned(8)));

namespace RendererProps {
typedef enum { kPtsLinesStripsFans = 1 << 0,
    kTriangles                     = 1 << 1,
    kQuads                         = 1 << 2 } tPrimType;

typedef enum { k3DirLights = 1 << 0,
    k8DirLights            = 1 << 1 } tNumDirLights;

typedef enum { k1PtLight = 1 << 0,
    k2PtLights           = 1 << 1,
    k8PtLights           = 1 << 2 } tNumPtLights;

typedef enum { kNoMaterial = 1 << 0,
    kDiffuse               = 1 << 1,
    kSpecular              = 1 << 2 } tPerVtxMaterial;

typedef enum { kLinear = 1 << 0,
    kIndexed           = 1 << 1 } tArrayAccess;

typedef enum { kNonClipped = 1 << 0,
    kClipped               = 1 << 1 } tClipping;
}

class CGeometryBlock;
class CVertArray;

/**
 * This class defines the interface for renderers.  Note
 * that it contains pure virtual methods and so
 * cannot be instantiated.
 */
class CRenderer {
protected:
    tU64 Capabilities;
    tU64 Requirements;

    // this class can't be instantiated
    CRenderer() {}
    CRenderer(tU64 caps, tU64 reqs)
        : Capabilities(caps)
        , Requirements(reqs)
    {
    }

    void SetCapabilities(tU64 caps) { Capabilities = caps; }
    void SetRequirements(tU64 reqs) { Requirements = reqs; }

public:
    virtual tU64 GetCapabilities() const { return Capabilities; }
    virtual tU64 GetRequirements() const { return Requirements; }

    /// called by the geometry manager when the default renderer context has changed,
    /// when the user context has changed, or after the renderer has been loaded
    /// (and a different renderer was in use).  The renderer must record all necessary
    /// context at this point (usually by adding it to the vif1 chain) as the
    /// rendering context may have changed when it is called to actually render with
    /// Draw*Arrays().
    /// @param primType the primitive type to render (can be a custom type)
    /// @param rcChanges changed in the rendering context as returned by
    /// CGLContext::GetRendererContextChanged().
    /// @param userRcChanged whether the user (custom) rendering context has changed
    virtual void InitContext(GLenum primType, tU32 rcChanges, bool userRcChanged) = 0;

    /// Load the renderer into vu0/vu1 memory.
    virtual void Load() = 0;

    /// Draw arrays of vertices that are accessed linearly (i.e., glDrawArrays)
    virtual void DrawLinearArrays(CGeometryBlock& block)
    {
        mError("This renderer doesn't do linear arrays");
    }
    /// Draw arrays of vertices that are accessed by index (i.e., glDrawElements)
    virtual void DrawIndexedArrays(CGeometryBlock& block)
    {
        mError("This renderer doesn't do indexed arrays");
    }

    /// Can the packets generated by this renderer for the given geometry be cached
    /// when called from a display list, or should they be rebuilt each time?
    /// (The default renderers, for example, don't cache packets that depend on the
    /// current normal when lighting is enabled.)
    virtual bool GetCachePackets(const CGeometryBlock& geometry) = 0;

    /// What parts of the render context are encoded into packets produced by
    /// this renderer?  When the packets are cached in display lists, this
    /// cached state must remain valid to continue using the cached packet.
    /// This method returns a CRendererProps bitmask with '1' set for each
    /// property that is cached in the packet.  Note that this does <b>not</b>
    /// include the render context kept by InitContext(); this will never be
    /// cached by ps2gl.
    /// The default renderers, for example, do not transfer normals even when
    /// specified if lighting is not enabled.  The packets they generate
    /// therefore depend on whether or not lighting is enabled, so they set the
    /// "Lighting" bit.
    virtual CRendererProps GetRenderContextDeps() = 0;

    /// Estimate the amount of memory, in qwords, the packet to render "geometry"
    /// will take.  (For display list cacheing.)
    virtual int GetPacketQwordSize(const CGeometryBlock& geometry) = 0;

    /// Return a pointer to the text name of this renderer
    virtual const char* GetName() = 0;
};

#endif // renderer_h
